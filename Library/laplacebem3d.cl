/* ------------------------------------------------------------
 This is the file "laplacebem3d.cl" of the H2Lib package.
 All rights reserved, Sven Christophersen 2015
 ------------------------------------------------------------ */

/**
 * @file laplacebem3d.cl
 * @author Sven Christophersen
 * @date 2015
 */

#ifndef LAPALCEBEM3DCL_H_
#define LAPALCEBEM3DCL_H_

/**
 * Source code of "laplacebem3d.cl" inside a string.
 */
const char laplacebem3d_ocl_src[] =
    {
        "\n"
            "#ifdef USE_FLOAT\n"
            "#define KERNEL_CONST_LAPLACEBEM3D 7.95774715459477e-02f\n"
            "#define KERNEL_CONST_2 7.95774715459477e-02f\n"
            "#define KERNEL_CONST_8 7.95774715459477e-02f\n"
            "#else\n"
            "#define KERNEL_CONST_LAPLACEBEM3D 7.95774715459477e-02\n"
            "#define KERNEL_CONST_2 3.978873577297385e-02\n"
            "#define KERNEL_CONST_8 9.9471839432434625e-03\n"
            "#endif\n"
            "\n"
            "inline field slp_eval(real dx, real dy, real dz) {\n"
            "  real norm, norm2;\n"
            "\n"
            "  norm2 = dx * dx + dy * dy + dz * dz;\n"
            "\n"
            "#ifndef USE_FLOAT\n"
            "  norm = convert_double(native_rsqrt(convert_float(norm2)));\n"
            "\n"
            "  norm = norm * (3.0 - norm2 * norm * norm);\n"
            "#else\n"
            "  norm = native_rsqrt(norm2);\n"
            "#endif\n"
            "\n"
            "#ifdef USE_COMPLEX\n"
            "  return (field) (norm, 0.0);\n"
            "#else\n"
            "  return norm;\n"
            "#endif\n"
            "}\n"
            "\n"
            "inline field dlp_eval(real dx, real dy, real dz, real *N) {\n"
            "  real norm, norm2;\n"
            "\n"
            "  norm2 = dx * dx + dy * dy + dz * dz;\n"
            "\n"
            "#ifndef USE_FLOAT\n"
            "  norm = convert_double(native_rsqrt(convert_float(norm2)));\n"
            "  norm = norm * (3.0 - norm2 * norm * norm);\n"
            "#else\n"
            "  norm = native_rsqrt(norm2);\n"
            "#endif\n"
            "\n"
            "#ifdef USE_COMPLEX\n"
            "  return (field) ((N[0] * dx + N[1] * dy + N[2] * dz) * norm * norm * norm, 0.0);\n"
            "#else\n"
            "  return (N[0] * dx + N[1] * dy + N[2] * dz) * norm * norm * norm;\n"
            "#endif\n"
            "}\n"
            "\n"
            "uint fast_select_quadrature( __global uint *geo_t, uint t, uint s, uint n) {\n"
            "  uint p;\n"
            "\n"
            "  p = 0;\n"
            "  p += (geo_t[t] == geo_t[s]);\n"
            "  p += (geo_t[t] == geo_t[s + n]);\n"
            "  p += (geo_t[t] == geo_t[s + 2 * n]);\n"
            "  p += (geo_t[t + n] == geo_t[s]);\n"
            "  p += (geo_t[t + n] == geo_t[s + n]);\n"
            "  p += (geo_t[t + n] == geo_t[s + 2 * n]);\n"
            "  p += (geo_t[t + 2 * n] == geo_t[s]);\n"
            "  p += (geo_t[t + 2 * n] == geo_t[s + n]);\n"
            "  p += (geo_t[t + 2 * n] == geo_t[s + 2 * n]);\n"
            "\n"
            "  return p;\n"
            "}\n"
            "\n"
            "uint select_quadrature( __global uint *geo_t, uint t, uint s, uint *tp,\n"
            "    uint *sp, uint n) {\n"
            "\n"
            "  uint p, q, i, j;\n"
            "\n"
            "  p = 0;\n"
            "  for (i = 0; i < 3; ++i) {\n"
            "    for (j = 0; j < 3; ++j) {\n"
            "      if (geo_t[t + i * n] == geo_t[s + j * n]) {\n"
            "        tp[p] = i;\n"
            "        sp[p] = j;\n"
            "        p++;\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  q = p;\n"
            "  for (i = 0; i < 3; i++) {\n"
            "    for (j = 0; j < q && geo_t[t + i * n] != geo_t[t + tp[j] * n]; j++)\n"
            "    ;\n"
            "    if (j == q)\n"
            "    tp[q++] = i;\n"
            "  }\n"
            "\n"
            "  q = p;\n"
            "  for (i = 0; i < 3; i++) {\n"
            "    for (j = 0; j < q && geo_t[s + i * n] != geo_t[s + sp[j] * n]; j++)\n"
            "    ;\n"
            "    if (j == q)\n"
            "    sp[q++] = i;\n"
            "  }\n"
            "\n"
            "  return p;\n"
            "}\n"
            "\n"
            "real REAL_SQR(real x) {\n"
            "  return x * x;\n"
            "}\n"
            "\n"
            "real REAL_SQRT(real x) {\n"
            "  return sqrt(x);\n"
            "}\n"
            "\n"
            "real gramdet2(__global real *A, __global real *B, __global real *C) {\n"
            "  real dx1, dx2, dx3, dy1, dy2, dy3, n[3];\n"
            "  dx1 = B[0] - A[0];\n"
            "  dx2 = B[1] - A[1];\n"
            "  dx3 = B[2] - A[2];\n"
            "\n"
            "  dy1 = C[0] - A[0];\n"
            "  dy2 = C[1] - A[1];\n"
            "  dy3 = C[2] - A[2];\n"
            "\n"
            "  n[0] = dx2 * dy3 - dx3 * dy2;\n"
            "  n[1] = dx3 * dy1 - dx1 * dy3;\n"
            "  n[2] = dx1 * dy2 - dx2 * dy1;\n"
            "\n"
            "  return REAL_SQR(n[0]) + REAL_SQR(n[1]) + REAL_SQR(n[2]);\n"
            "}\n"
            "\n"
            "void normal(__global real *A, __global real *B, __global real *C, real *N) {\n"
            "  real dx1, dx2, dx3, dy1, dy2, dy3;\n"
            "  dx1 = B[0] - A[0];\n"
            "  dx2 = B[1] - A[1];\n"
            "  dx3 = B[2] - A[2];\n"
            "\n"
            "  dy1 = C[0] - A[0];\n"
            "  dy2 = C[1] - A[1];\n"
            "  dy3 = C[2] - A[2];\n"
            "\n"
            "  N[0] = dx2 * dy3 - dx3 * dy2;\n"
            "  N[1] = dx3 * dy1 - dx1 * dy3;\n"
            "  N[2] = dx1 * dy2 - dx2 * dy1;\n"
            "}\n"
            "\n"
            "field slp_cc_dist(__constant real *quad, uint nq2, __global real *A_t,\n"
            "    __global real *B_t, __global real *C_t, __global real *A_s,\n"
            "    __global real *B_s, __global real *C_s) {\n"
            "\n"
            "  uint i, j, k, l;\n"
            "  real tx, sx, ty, sy, wi, wj, wk, w, dx, dy, dz, dx1, dy1, dz1, dx2, dy2, dz2,\n"
            "  dx3, dy3, dz3;\n"
            "  field sum;\n"
            "  real A[3], BA_t[3], CB_t[3], BA_s[3], CB_s[3];\n"
            "  __local real quad_x[20], quad_w[20];\n"
            "\n"
            "  A[0] = A_t[0] - A_s[0];\n"
            "  A[1] = A_t[1] - A_s[1];\n"
            "  A[2] = A_t[2] - A_s[2];\n"
            "\n"
            "  BA_t[0] = (B_t[0] - A_t[0]);\n"
            "  BA_t[1] = (B_t[1] - A_t[1]);\n"
            "  BA_t[2] = (B_t[2] - A_t[2]);\n"
            "\n"
            "  CB_t[0] = (C_t[0] - B_t[0]);\n"
            "  CB_t[1] = (C_t[1] - B_t[1]);\n"
            "  CB_t[2] = (C_t[2] - B_t[2]);\n"
            "\n"
            "  BA_s[0] = (B_s[0] - A_s[0]);\n"
            "  BA_s[1] = (B_s[1] - A_s[1]);\n"
            "  BA_s[2] = (B_s[2] - A_s[2]);\n"
            "\n"
            "  CB_s[0] = (C_s[0] - B_s[0]);\n"
            "  CB_s[1] = (C_s[1] - B_s[1]);\n"
            "  CB_s[2] = (C_s[2] - B_s[2]);\n"
            "\n"
            "  nq2 /= 2;\n"
            "\n"
            "  for (i = 0; i < nq2; ++i) {\n"
            "    quad_x[i] = quad[2 * i];\n"
            "    quad_w[i] = quad[2 * i + 1];\n"
            "  }\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 1) {\n"
            "    tx = quad_x[i];\n"
            "    wi = tx * quad_w[i];\n"
            "\n"
            "    dx1 = A[0] + BA_t[0] * tx;\n"
            "    dy1 = A[1] + BA_t[1] * tx;\n"
            "    dz1 = A[2] + BA_t[2] * tx;\n"
            "    for (j = 0; j < nq2; j += 1) {\n"
            "      sx = tx * quad_x[j];\n"
            "      wj = wi * quad_w[j];\n"
            "\n"
            "      dx2 = dx1 + CB_t[0] * sx;\n"
            "      dy2 = dy1 + CB_t[1] * sx;\n"
            "      dz2 = dz1 + CB_t[2] * sx;\n"
            "\n"
            "      for (k = 0; k < nq2; k += 1) {\n"
            "        ty = quad_x[k];\n"
            "        wk = wj * ty * quad_w[k];\n"
            "\n"
            "        dx3 = dx2 - BA_s[0] * ty;\n"
            "        dy3 = dy2 - BA_s[1] * ty;\n"
            "        dz3 = dz2 - BA_s[2] * ty;\n"
            "        for (l = 0; l < nq2; l += 1) {\n"
            "          sy = ty * quad_x[l];\n"
            "\n"
            "          dx = dx3 - CB_s[0] * sy;\n"
            "          dy = dy3 - CB_s[1] * sy;\n"
            "          dz = dz3 - CB_s[2] * sy;\n"
            "\n"
            "          sum += wk * quad_w[l] * slp_eval(dx, dy, dz);\n"
            "        }\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * REAL_SQRT(gramdet2(A_t, B_t, C_t) * gramdet2(A_s, B_s, C_s));\n"
            "}\n"
            "\n"
            "field slp_cc_vert(__constant real *quad, uint nq2, __global real *A,\n"
            "    __global real *B_t, __global real *C_t, __global real *B_s,\n"
            "    __global real *C_s) {\n"
            "  uint i, j, k, l;\n"
            "  real tx, sx, ty, sy, wi, wj, wk, dx, dy, dz;\n"
            "  field sum, sum2;\n"
            "  real BA_t[3], CB_t[3], BA_s[3], CB_s[3];\n"
            "  __local real quad_x[22], quad_w[22];\n"
            "\n"
            "  BA_t[0] = (B_t[0] - A[0]);\n"
            "  BA_t[1] = (B_t[1] - A[1]);\n"
            "  BA_t[2] = (B_t[2] - A[2]);\n"
            "\n"
            "  CB_t[0] = (C_t[0] - B_t[0]);\n"
            "  CB_t[1] = (C_t[1] - B_t[1]);\n"
            "  CB_t[2] = (C_t[2] - B_t[2]);\n"
            "\n"
            "  BA_s[0] = (B_s[0] - A[0]);\n"
            "  BA_s[1] = (B_s[1] - A[1]);\n"
            "  BA_s[2] = (B_s[2] - A[2]);\n"
            "\n"
            "  CB_s[0] = (C_s[0] - B_s[0]);\n"
            "  CB_s[1] = (C_s[1] - B_s[1]);\n"
            "  CB_s[2] = (C_s[2] - B_s[2]);\n"
            "\n"
            "  nq2 /= 2;\n"
            "\n"
            "  for (i = 0; i < nq2; ++i) {\n"
            "    quad_x[i] = quad[2 * i];\n"
            "    quad_w[i] = quad[2 * i + 1];\n"
            "  }\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 1) {\n"
            "    wi = quad_w[i] * quad_x[i];\n"
            "    for (j = 0; j < nq2; j += 1) {\n"
            "      wj = wi * quad_w[j];\n"
            "      for (k = 0; k < nq2; k += 1) {\n"
            "        wk = wj * quad_w[k];\n"
            "        for (l = 0; l < nq2; l += 1) {\n"
            "          tx = quad_x[l];\n"
            "          sx = quad_x[j] * quad_x[l];\n"
            "          ty = quad_x[i] * quad_x[l];\n"
            "          sy = quad_x[i] * quad_x[k] * quad_x[l];\n"
            "\n"
            "          dx = BA_t[0] * tx + CB_t[0] * sx - BA_s[0] * ty - CB_s[0] * sy;\n"
            "          dy = BA_t[1] * tx + CB_t[1] * sx - BA_s[1] * ty - CB_s[1] * sy;\n"
            "          dz = BA_t[2] * tx + CB_t[2] * sx - BA_s[2] * ty - CB_s[2] * sy;\n"
            "\n"
            "          sum2 = slp_eval(dx, dy, dz);\n"
            "\n"
            "          dx = BA_t[0] * ty + CB_t[0] * sy - BA_s[0] * tx - CB_s[0] * sx;\n"
            "          dy = BA_t[1] * ty + CB_t[1] * sy - BA_s[1] * tx - CB_s[1] * sx;\n"
            "          dz = BA_t[2] * ty + CB_t[2] * sy - BA_s[2] * tx - CB_s[2] * sx;\n"
            "\n"
            "          sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "          sum += sum2 * wk * quad_w[l] * quad_x[l] * quad_x[l] * quad_x[l];\n"
            "        }\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * REAL_SQRT(gramdet2(A, B_t, C_t) * gramdet2(A, B_s, C_s));\n"
            "}\n"
            "\n"
            "field slp_cc_edge(__constant real *quad, uint nq2, __global real *A,\n"
            "    __global real *B, __global real *C_t, __global real *C_s) {\n"
            "  uint i, j, k, l;\n"
            "  real eta1, eta2, xi1, tx, sx, sy, wi, wj, dx, dy, dz;\n"
            "  field sum, sum2;\n"
            "  real BA[3], CB_t[3], CB_s[3];\n"
            "\n"
            "  BA[0] = B[0] - A[0];\n"
            "  BA[1] = B[1] - A[1];\n"
            "  BA[2] = B[2] - A[2];\n"
            "\n"
            "  CB_t[0] = (C_t[0] - B[0]);\n"
            "  CB_t[1] = (C_t[1] - B[1]);\n"
            "  CB_t[2] = (C_t[2] - B[2]);\n"
            "\n"
            "  CB_s[0] = (C_s[0] - B[0]);\n"
            "  CB_s[1] = (C_s[1] - B[1]);\n"
            "  CB_s[2] = (C_s[2] - B[2]);\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 2) {\n"
            "    eta1 = quad[i];\n"
            "    wi = quad[i + 1];\n"
            "    for (j = 0; j < nq2; j += 2) {\n"
            "      eta2 = quad[j];\n"
            "      wj = wi * quad[j + 1];\n"
            "      for (k = 0; k < nq2; k += 2) {\n"
            "        xi1 = quad[k];\n"
            "\n"
            "        tx = xi1 * eta1;\n"
            "        sx = xi1 * eta1 * eta2;\n"
            "        sy = -xi1 * (eta1 - r_one);\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 = slp_eval(dx, dy, dz);\n"
            "\n"
            "        tx = xi1 * eta1 * eta2;\n"
            "        sx = xi1 * eta1;\n"
            "        sy = -xi1 * (eta1 * eta2 - r_one);\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "        sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "        tx = xi1 * (r_one - eta1);\n"
            "        sx = xi1;\n"
            "        sy = xi1 * eta1 * eta2;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "        tx = xi1 * eta1 * (eta2 - r_one);\n"
            "        sx = xi1 * eta1 * eta2;\n"
            "        sy = xi1;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "        tx = xi1 * (eta1 * eta2 - r_one);\n"
            "        sx = xi1 * eta1 * eta2;\n"
            "        sy = xi1 * eta1;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "        tx = xi1 * (eta1 - r_one);\n"
            "        sx = xi1 * eta1;\n"
            "        sy = xi1 * eta1 * eta2;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "        sum += sum2 * wj * quad[k + 1] * (r_one - xi1) * xi1 * xi1 * eta1;\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * REAL_SQRT(gramdet2(A, B, C_t) * gramdet2(A, B, C_s));\n"
            "}\n"
            "\n"
            "field slp_cc_iden(__constant real *quad, uint nq2, __global real *A,\n"
            "    __global real *B, __global real *C) {\n"
            "  uint i, j, k, l;\n"
            "  real eta, xi1, xi2, tx, sx, wi, wj, wk, dx, dy, dz, dx1, dz1, dx2, dz2, dx3,\n"
            "  dz3, sum3;\n"
            "  field sum, sum2;\n"
            "\n"
            "  dx1 = B[0] - A[0];\n"
            "  dx2 = B[1] - A[1];\n"
            "  dx3 = B[2] - A[2];\n"
            "\n"
            "  dz1 = C[0] - B[0];\n"
            "  dz2 = C[1] - B[1];\n"
            "  dz3 = C[2] - B[2];\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 2) {\n"
            "    eta = quad[i];\n"
            "    wi = quad[i + 1];\n"
            "    for (j = 0; j < nq2; j += 2) {\n"
            "      xi1 = quad[j];\n"
            "      wj = wi * quad[j + 1];\n"
            "\n"
            "      tx = xi1 * eta;\n"
            "      sx = xi1;\n"
            "\n"
            "      dx = dx1 * tx + dz1 * sx;\n"
            "      dy = dx2 * tx + dz2 * sx;\n"
            "      dz = dx3 * tx + dz3 * sx;\n"
            "\n"
            "      sum2 = slp_eval(dx, dy, dz);\n"
            "\n"
            "      //////////////////////////////////////////////////\n"
            "\n"
            "      tx = xi1;\n"
            "      sx = xi1 * eta;\n"
            "\n"
            "      dx = dx1 * tx + dz1 * sx;\n"
            "      dy = dx2 * tx + dz2 * sx;\n"
            "      dz = dx3 * tx + dz3 * sx;\n"
            "\n"
            "      sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "      //////////////////////////////////////////////////\n"
            "\n"
            "      tx = xi1 * eta;\n"
            "      sx = xi1 * (eta - r_one);\n"
            "\n"
            "      dx = dx1 * tx + dz1 * sx;\n"
            "      dy = dx2 * tx + dz2 * sx;\n"
            "      dz = dx3 * tx + dz3 * sx;\n"
            "\n"
            "      sum2 += slp_eval(dx, dy, dz);\n"
            "\n"
            "      sum3 = 0.0;\n"
            "      for (k = 0; k < nq2; k += 2) {\n"
            "        xi2 = quad[k] * (r_one - xi1);\n"
            "        wk = wj * quad[k + 1] * (r_one - xi1);\n"
            "        for (l = 0; l < nq2; l += 2) {\n"
            "          sum3 += wk * quad[l + 1] * (r_one - xi1 - xi2) * xi1;\n"
            "        }\n"
            "      }\n"
            "\n"
            "      sum += r_two * sum2 * sum3;\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * gramdet2(A, B, C);\n"
            "}\n"
            "\n"
            "__kernel void assemble_slp_cc_list_0(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  field sum;\n"
            "  __global real *A_t, *B_t, *C_t, *A_s, *B_s, *C_s;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    A_t = geo_x + 3 * geo_t[tt + 0 * triangles];\n"
            "    B_t = geo_x + 3 * geo_t[tt + 1 * triangles];\n"
            "    C_t = geo_x + 3 * geo_t[tt + 2 * triangles];\n"
            "\n"
            "    A_s = geo_x + 3 * geo_t[ss + 0 * triangles];\n"
            "    B_s = geo_x + 3 * geo_t[ss + 1 * triangles];\n"
            "    C_s = geo_x + 3 * geo_t[ss + 2 * triangles];\n"
            "\n"
            "    sum = slp_cc_dist(xwq, nq2, A_t, B_t, C_t, A_s, B_s, C_s);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_2;\n"
            "  }\n"
            "}\n"
            "\n"
            "__kernel void assemble_slp_cc_list_1(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  uint tp[3], sp[3];\n"
            "  field sum;\n"
            "  __global real *A, *B_t, *C_t, *B_s, *C_s;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    select_quadrature(geo_t, tt, ss, tp, sp, triangles);\n"
            "\n"
            "    A = geo_x + 3 * geo_t[tt + tp[0] * triangles];\n"
            "    B_t = geo_x + 3 * geo_t[tt + tp[1] * triangles];\n"
            "    C_t = geo_x + 3 * geo_t[tt + tp[2] * triangles];\n"
            "\n"
            "    B_s = geo_x + 3 * geo_t[ss + sp[1] * triangles];\n"
            "    C_s = geo_x + 3 * geo_t[ss + sp[2] * triangles];\n"
            "\n"
            "    sum = slp_cc_vert(xwq, nq2, A, B_t, C_t, B_s, C_s);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_2;\n"
            "  }\n"
            "}\n"
            "\n"
            "__kernel void assemble_slp_cc_list_2(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  uint tp[3], sp[3];\n"
            "  field sum;\n"
            "  __global real *A, *B, *C_t, *C_s;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    select_quadrature(geo_t, tt, ss, tp, sp, triangles);\n"
            "\n"
            "    A = geo_x + 3 * geo_t[tt + tp[0] * triangles];\n"
            "    B = geo_x + 3 * geo_t[tt + tp[1] * triangles];\n"
            "    C_t = geo_x + 3 * geo_t[tt + tp[2] * triangles];\n"
            "\n"
            "    C_s = geo_x + 3 * geo_t[ss + sp[2] * triangles];\n"
            "\n"
            "    sum = slp_cc_edge(xwq, nq2, A, B, C_t, C_s);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_2;\n"
            "  }\n"
            "}\n"
            "\n"
            "__kernel void assemble_slp_cc_list_3(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  field sum;\n"
            "  __global real *A, *B, *C;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    A = geo_x + 3 * geo_t[tt + 0 * triangles];\n"
            "    B = geo_x + 3 * geo_t[tt + 1 * triangles];\n"
            "    C = geo_x + 3 * geo_t[tt + 2 * triangles];\n"
            "\n"
            "    sum = slp_cc_iden(xwq, nq2, A, B, C);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_2;\n"
            "  }\n"
            "}\n"
            "\n"
            "field dlp_cc_dist(__constant real *quad, uint nq2, __global real *A_t,\n"
            "    __global real *B_t, __global real *C_t, __global real *A_s,\n"
            "    __global real *B_s, __global real *C_s, real *n_s) {\n"
            "\n"
            "  uint i, j, k, l;\n"
            "  real tx, sx, ty, sy, wi, wj, wk, w, dx, dy, dz, dx1, dy1, dz1, dx2, dy2, dz2,\n"
            "  dx3, dy3, dz3;\n"
            "  field sum;\n"
            "  real A[3], BA_t[3], CB_t[3], BA_s[3], CB_s[3];\n"
            "  __local real quad_x[20], quad_w[20];\n"
            "\n"
            "  A[0] = A_t[0] - A_s[0];\n"
            "  A[1] = A_t[1] - A_s[1];\n"
            "  A[2] = A_t[2] - A_s[2];\n"
            "\n"
            "  BA_t[0] = (B_t[0] - A_t[0]);\n"
            "  BA_t[1] = (B_t[1] - A_t[1]);\n"
            "  BA_t[2] = (B_t[2] - A_t[2]);\n"
            "\n"
            "  CB_t[0] = (C_t[0] - B_t[0]);\n"
            "  CB_t[1] = (C_t[1] - B_t[1]);\n"
            "  CB_t[2] = (C_t[2] - B_t[2]);\n"
            "\n"
            "  BA_s[0] = (B_s[0] - A_s[0]);\n"
            "  BA_s[1] = (B_s[1] - A_s[1]);\n"
            "  BA_s[2] = (B_s[2] - A_s[2]);\n"
            "\n"
            "  CB_s[0] = (C_s[0] - B_s[0]);\n"
            "  CB_s[1] = (C_s[1] - B_s[1]);\n"
            "  CB_s[2] = (C_s[2] - B_s[2]);\n"
            "\n"
            "  nq2 /= 2;\n"
            "\n"
            "  for (i = 0; i < nq2; ++i) {\n"
            "    quad_x[i] = quad[2 * i];\n"
            "    quad_w[i] = quad[2 * i + 1];\n"
            "  }\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 1) {\n"
            "    tx = quad_x[i];\n"
            "    wi = tx * quad_w[i];\n"
            "\n"
            "    dx1 = A[0] + BA_t[0] * tx;\n"
            "    dy1 = A[1] + BA_t[1] * tx;\n"
            "    dz1 = A[2] + BA_t[2] * tx;\n"
            "    for (j = 0; j < nq2; j += 1) {\n"
            "      sx = tx * quad_x[j];\n"
            "      wj = wi * quad_w[j];\n"
            "\n"
            "      dx2 = dx1 + CB_t[0] * sx;\n"
            "      dy2 = dy1 + CB_t[1] * sx;\n"
            "      dz2 = dz1 + CB_t[2] * sx;\n"
            "\n"
            "      for (k = 0; k < nq2; k += 1) {\n"
            "        ty = quad_x[k];\n"
            "        wk = wj * ty * quad_w[k];\n"
            "\n"
            "        dx3 = dx2 - BA_s[0] * ty;\n"
            "        dy3 = dy2 - BA_s[1] * ty;\n"
            "        dz3 = dz2 - BA_s[2] * ty;\n"
            "        for (l = 0; l < nq2; l += 1) {\n"
            "          sy = ty * quad_x[l];\n"
            "\n"
            "          dx = dx3 - CB_s[0] * sy;\n"
            "          dy = dy3 - CB_s[1] * sy;\n"
            "          dz = dz3 - CB_s[2] * sy;\n"
            "\n"
            "          sum += wk * quad_w[l] * dlp_eval(dx, dy, dz, n_s);\n"
            "        }\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * REAL_SQRT(gramdet2(A_t, B_t, C_t));\n"
            "}\n"
            "\n"
            "field dlp_cc_vert(__constant real *quad, uint nq2, __global real *A,\n"
            "    __global real *B_t, __global real *C_t, __global real *B_s,\n"
            "    __global real *C_s, real *n_s) {\n"
            "  uint i, j, k, l;\n"
            "  real tx, sx, ty, sy, wi, wj, wk, dx, dy, dz;\n"
            "  field sum, sum2;\n"
            "  real BA_t[3], CB_t[3], BA_s[3], CB_s[3];\n"
            "  __local real quad_x[22], quad_w[22];\n"
            "\n"
            "  BA_t[0] = (B_t[0] - A[0]);\n"
            "  BA_t[1] = (B_t[1] - A[1]);\n"
            "  BA_t[2] = (B_t[2] - A[2]);\n"
            "\n"
            "  CB_t[0] = (C_t[0] - B_t[0]);\n"
            "  CB_t[1] = (C_t[1] - B_t[1]);\n"
            "  CB_t[2] = (C_t[2] - B_t[2]);\n"
            "\n"
            "  BA_s[0] = (B_s[0] - A[0]);\n"
            "  BA_s[1] = (B_s[1] - A[1]);\n"
            "  BA_s[2] = (B_s[2] - A[2]);\n"
            "\n"
            "  CB_s[0] = (C_s[0] - B_s[0]);\n"
            "  CB_s[1] = (C_s[1] - B_s[1]);\n"
            "  CB_s[2] = (C_s[2] - B_s[2]);\n"
            "\n"
            "  nq2 /= 2;\n"
            "\n"
            "  for (i = 0; i < nq2; ++i) {\n"
            "    quad_x[i] = quad[2 * i];\n"
            "    quad_w[i] = quad[2 * i + 1];\n"
            "  }\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 1) {\n"
            "    wi = quad_w[i] * quad_x[i];\n"
            "    for (j = 0; j < nq2; j += 1) {\n"
            "      wj = wi * quad_w[j];\n"
            "      for (k = 0; k < nq2; k += 1) {\n"
            "        wk = wj * quad_w[k];\n"
            "        for (l = 0; l < nq2; l += 1) {\n"
            "          tx = quad_x[l];\n"
            "          sx = quad_x[j] * quad_x[l];\n"
            "          ty = quad_x[i] * quad_x[l];\n"
            "          sy = quad_x[i] * quad_x[k] * quad_x[l];\n"
            "\n"
            "          dx = BA_t[0] * tx + CB_t[0] * sx - BA_s[0] * ty - CB_s[0] * sy;\n"
            "          dy = BA_t[1] * tx + CB_t[1] * sx - BA_s[1] * ty - CB_s[1] * sy;\n"
            "          dz = BA_t[2] * tx + CB_t[2] * sx - BA_s[2] * ty - CB_s[2] * sy;\n"
            "\n"
            "          sum2 = dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "          dx = BA_t[0] * ty + CB_t[0] * sy - BA_s[0] * tx - CB_s[0] * sx;\n"
            "          dy = BA_t[1] * ty + CB_t[1] * sy - BA_s[1] * tx - CB_s[1] * sx;\n"
            "          dz = BA_t[2] * ty + CB_t[2] * sy - BA_s[2] * tx - CB_s[2] * sx;\n"
            "\n"
            "          sum2 += dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "          sum += sum2 * wk * quad_w[l] * quad_x[l] * quad_x[l] * quad_x[l];\n"
            "        }\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * REAL_SQRT(gramdet2(A, B_t, C_t));\n"
            "}\n"
            "\n"
            "field dlp_cc_edge(__constant real *quad, uint nq2, __global real *A,\n"
            "    __global real *B, __global real *C_t, __global real *C_s, real *n_s) {\n"
            "  uint i, j, k, l;\n"
            "  real eta1, eta2, xi1, tx, sx, sy, wi, wj, dx, dy, dz;\n"
            "  field sum, sum2;\n"
            "  real BA[3], CB_t[3], CB_s[3];\n"
            "\n"
            "  BA[0] = B[0] - A[0];\n"
            "  BA[1] = B[1] - A[1];\n"
            "  BA[2] = B[2] - A[2];\n"
            "\n"
            "  CB_t[0] = (C_t[0] - B[0]);\n"
            "  CB_t[1] = (C_t[1] - B[1]);\n"
            "  CB_t[2] = (C_t[2] - B[2]);\n"
            "\n"
            "  CB_s[0] = (C_s[0] - B[0]);\n"
            "  CB_s[1] = (C_s[1] - B[1]);\n"
            "  CB_s[2] = (C_s[2] - B[2]);\n"
            "\n"
            "  sum = f_zero;\n"
            "\n"
            "  for (i = 0; i < nq2; i += 2) {\n"
            "    eta1 = quad[i];\n"
            "    wi = quad[i + 1];\n"
            "    for (j = 0; j < nq2; j += 2) {\n"
            "      eta2 = quad[j];\n"
            "      wj = wi * quad[j + 1];\n"
            "      for (k = 0; k < nq2; k += 2) {\n"
            "        xi1 = quad[k];\n"
            "\n"
            "        tx = xi1 * eta1;\n"
            "        sx = xi1 * eta1 * eta2;\n"
            "        sy = -xi1 * (eta1 - r_one);\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 = dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "        tx = xi1 * eta1 * eta2;\n"
            "        sx = xi1 * eta1;\n"
            "        sy = -xi1 * (eta1 * eta2 - r_one);\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "        sum2 += dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "        tx = xi1 * (r_one - eta1);\n"
            "        sx = xi1;\n"
            "        sy = xi1 * eta1 * eta2;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "        tx = xi1 * eta1 * (eta2 - r_one);\n"
            "        sx = xi1 * eta1 * eta2;\n"
            "        sy = xi1;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "        tx = xi1 * (eta1 * eta2 - r_one);\n"
            "        sx = xi1 * eta1 * eta2;\n"
            "        sy = xi1 * eta1;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "        tx = xi1 * (eta1 - r_one);\n"
            "        sx = xi1 * eta1;\n"
            "        sy = xi1 * eta1 * eta2;\n"
            "\n"
            "        dx = BA[0] * tx + CB_t[0] * sx - CB_s[0] * sy;\n"
            "        dy = BA[1] * tx + CB_t[1] * sx - CB_s[1] * sy;\n"
            "        dz = BA[2] * tx + CB_t[2] * sx - CB_s[2] * sy;\n"
            "\n"
            "        sum2 += dlp_eval(dx, dy, dz, n_s);\n"
            "\n"
            "        sum += sum2 * wj * quad[k + 1] * (r_one - xi1) * xi1 * xi1 * eta1;\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "\n"
            "  return sum * REAL_SQRT(gramdet2(A, B, C_t));\n"
            "}\n"
            "\n"
            "field dlp_cc_iden(__constant real *quad, uint nq2, __global real *A,\n"
            "    __global real *B, __global real *C, real *n) {\n"
            "  real alpha = 0.5;\n"
            "\n"
            "#ifdef USE_COMPLEX\n"
            "  return (field) (0.5 * alpha * REAL_SQRT(gramdet2(A, B, C)), 0.0);\n"
            "#else\n"
            "  return 0.5 * alpha * REAL_SQRT(gramdet2(A, B, C));\n"
            "#endif\n"
            "}\n"
            "\n"
            "__kernel void assemble_dlp_cc_list_0(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  field sum;\n"
            "  real N_s[3];\n"
            "  __global real *A_t, *B_t, *C_t, *A_s, *B_s, *C_s;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    A_t = geo_x + 3 * geo_t[tt + 0 * triangles];\n"
            "    B_t = geo_x + 3 * geo_t[tt + 1 * triangles];\n"
            "    C_t = geo_x + 3 * geo_t[tt + 2 * triangles];\n"
            "\n"
            "    A_s = geo_x + 3 * geo_t[ss + 0 * triangles];\n"
            "    B_s = geo_x + 3 * geo_t[ss + 1 * triangles];\n"
            "    C_s = geo_x + 3 * geo_t[ss + 2 * triangles];\n"
            "\n"
            "    normal(A_s, B_s, C_s, N_s);\n"
            "\n"
            "    sum = dlp_cc_dist(xwq, nq2, A_t, B_t, C_t, A_s, B_s, C_s, N_s);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_8;\n"
            "  }\n"
            "}\n"
            "\n"
            "__kernel void assemble_dlp_cc_list_1(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  uint tp[3], sp[3];\n"
            "  field sum;\n"
            "  real N_s[3];\n"
            "  __global real *A, *B_t, *C_t, *B_s, *C_s;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    select_quadrature(geo_t, tt, ss, tp, sp, triangles);\n"
            "\n"
            "    A = geo_x + 3 * geo_t[tt + tp[0] * triangles];\n"
            "    B_t = geo_x + 3 * geo_t[tt + tp[1] * triangles];\n"
            "    C_t = geo_x + 3 * geo_t[tt + tp[2] * triangles];\n"
            "\n"
            "    B_s = geo_x + 3 * geo_t[ss + sp[1] * triangles];\n"
            "    C_s = geo_x + 3 * geo_t[ss + sp[2] * triangles];\n"
            "\n"
            "    normal(geo_x + 3 * geo_t[ss + 0 * triangles],\n"
            "        geo_x + 3 * geo_t[ss + 1 * triangles],\n"
            "        geo_x + 3 * geo_t[ss + 2 * triangles], N_s);\n"
            "\n"
            "    sum = dlp_cc_vert(xwq, nq2, A, B_t, C_t, B_s, C_s, N_s);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_8;\n"
            "  }\n"
            "}\n"
            "\n"
            "__kernel void assemble_dlp_cc_list_2(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  uint tp[3], sp[3];\n"
            "  field sum;\n"
            "  real N_s[3];\n"
            "  __global real *A, *B, *C_t, *C_s;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    select_quadrature(geo_t, tt, ss, tp, sp, triangles);\n"
            "\n"
            "    A = geo_x + 3 * geo_t[tt + tp[0] * triangles];\n"
            "    B = geo_x + 3 * geo_t[tt + tp[1] * triangles];\n"
            "    C_t = geo_x + 3 * geo_t[tt + tp[2] * triangles];\n"
            "\n"
            "    C_s = geo_x + 3 * geo_t[ss + sp[2] * triangles];\n"
            "\n"
            "    normal(geo_x + 3 * geo_t[ss + 0 * triangles],\n"
            "        geo_x + 3 * geo_t[ss + 1 * triangles],\n"
            "        geo_x + 3 * geo_t[ss + 2 * triangles], N_s);\n"
            "\n"
            "    sum = dlp_cc_edge(xwq, nq2, A, B, C_t, C_s, N_s);\n"
            "\n"
            "    N[index] = sum * KERNEL_CONST_8;\n"
            "  }\n"
            "}\n"
            "\n"
            "__kernel void assemble_dlp_cc_list_3(__constant real *xwq, uint nq2,\n"
            "    __global uint *geo_t, __global real *geo_x, uint triangles,\n"
            "    __global uint *ridx, __global uint *cidx, __global field *N, uint workitems) {\n"
            "\n"
            "  uint index, tt, ss;\n"
            "  field sum;\n"
            "  real N_s[3];\n"
            "  __global real *A, *B, *C;\n"
            "\n"
            "  index = get_global_id(0);\n"
            "\n"
            "  if (index < workitems) {\n"
            "    tt = ridx[index];\n"
            "    ss = cidx[index];\n"
            "\n"
            "    A = geo_x + 3 * geo_t[tt + 0 * triangles];\n"
            "    B = geo_x + 3 * geo_t[tt + 1 * triangles];\n"
            "    C = geo_x + 3 * geo_t[tt + 2 * triangles];\n"
            "\n"
            "    normal(A, B, C, N_s);\n"
            "\n"
            "    sum = dlp_cc_iden(xwq, nq2, A, B, C, N_s);\n"
            "\n"
            "    N[index] = sum;\n"
            "  }\n"
            "}\n" };

#endif /* LAPLACEBEM3DCL_H_ */
