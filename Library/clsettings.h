/* ------------------------------------------------------------
 This is the file "clsettings.h" of the H2Lib package.
 All rights reserved, Sven Christophersen 2015
 ------------------------------------------------------------ */

/**
 * @file clsettings.h
 * @author Sven Christophersen
 * @date 2015
 */

#ifndef CLSETTINGS_H_
#define CLSETTINGS_H_

/** @defgroup clsettings clsettings
 *  @brief Fundamental types and macros for OpenCL computations.
 *  @{ */

/**
 * Source code of "clsettings.h" inside a string.
 */
const char clsettings_src[] = { "\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"#if USE_OPENCL\n"
"/** @cond DEBUG */\n"
"#define OCL_SYNTAX_HIGHLIGHT 1\n"
"/** @endcond */\n"
"#endif\n"
"\n"
"#if OCL_SYNTAX_HIGHLIGHT\n"
"/** @cond DEBUG */\n"
"#define __kernel\n"
"#define __global\n"
"#define __local\n"
"#define __constant\n"
"/** @endcond */\n"
"#endif\n"
"\n"
"/** @brief @ref real floating point type.\n"
" *\n"
" *  This type is used, e.g., for geometric coordinates, norms\n"
" *  and diagonal elements of self-adjoint matrices. */\n"
"#ifdef USE_FLOAT\n"
"typedef float real;\n"
"#else\n"
"typedef double real;\n"
"#endif\n"
"\n"
"/** @brief Field type.\n"
" *\n"
" *  This type is used in the linear algebra modules to represent\n"
" *  the coefficients of matrices and vectors. */\n"
"#ifdef USE_FLOAT\n"
"#ifdef USE_COMPLEX\n"
"typedef float2 field;\n"
"#else\n"
"typedef float field;\n"
"#endif\n"
"#else\n"
"#ifdef USE_COMPLEX\n"
"typedef double2 field;\n"
"#else\n"
"typedef double field;\n"
"#endif\n"
"#endif\n"
"\n"
"/** @brief Define the imaginary unit. */\n"
"#ifdef USE_FLOAT\n"
"#ifdef USE_COMPLEX\n"
"#define I ((field)(0.0f,1.0f))\n"
"#else\n"
"\n"
"#endif\n"
"#else\n"
"#ifdef USE_COMPLEX\n"
"#define I ((field)(0.0,1.0))\n"
"#else\n"
"#endif\n"
"#endif\n"
"\n"
"/** @brief @ref real constant zero */\n"
"__constant static real r_zero;\n"
"\n"
"/** @brief @ref real constant one */\n"
"__constant static real r_one;\n"
"\n"
"/** @brief @ref real constant minus one */\n"
"__constant static real r_minusone;\n"
"\n"
"/** @brief @ref real constant two */\n"
"__constant static real r_two;\n"
"\n"
"/** @brief @ref field constant zero */\n"
"__constant static field f_zero;\n"
"\n"
"/** @brief @ref field constant one */\n"
"__constant static field f_one;\n"
"\n"
"/** @brief @ref field constant minus one */\n"
"__constant static field f_minusone;\n"
"\n"
"#ifdef USE_FLOAT\n"
"__constant static real r_zero = 0.0f;\n"
"__constant static real r_one = 1.0f;\n"
"__constant static real r_minusone = -1.0f;\n"
"__constant static real r_two = 2.0f;\n"
"\n"
"#ifdef USE_COMPLEX\n"
"__constant static field f_zero = (field) (0.0f,0.0f);\n"
"__constant static field f_one = (field) (1.0f, 0.0f);\n"
"__constant static field f_minusone = (field) (-1.0f, 0.0f);\n"
"#else\n"
"__constant static field f_zero = 0.0f;\n"
"__constant static field f_one = 1.0f;\n"
"__constant static field f_minusone = -1.0f;\n"
"#endif\n"
"#else\n"
"__constant static real r_zero = 0.0;\n"
"__constant static real r_one = 1.0;\n"
"__constant static real r_minusone = -1.0;\n"
"__constant static real r_two = 2.0;\n"
"\n"
"#ifdef USE_COMPLEX\n"
"__constant static field f_zero = (field) (0.0, 0.0);\n"
"__constant static field f_one = (field) (1.0, 0.0);\n"
"__constant static field f_minusone = (field) (-1.0, 0.0);\n"
"#else\n"
"__constant static field f_zero = 0.0;\n"
"__constant static field f_one = 1.0;\n"
"__constant static field f_minusone = -1.0;\n"
"#endif\n"
"#endif\n"
"\n"
"/****************************************************\n"
" * basis operations on complex numbers\n"
" ****************************************************/\n"
"\n"
"#ifdef USE_COMPLEX\n"
"/**\n"
" * @brief Returns the real part of a complex number z.\n"
" *\n"
" * @param z Complex number given by z = a + b * I\n"
" * @return Real part of z: Re(z) = a.\n"
" */\n"
"inline real REAL(field z) {\n"
"  return z.x;\n"
"}\n"
"\n"
"/**\n"
" * @brief Returns the imaginary part of a complex number z.\n"
" *\n"
" * @param z Complex number given by z = a + b * I\n"
" * @return Imaginary part of z: IM(z) = b.\n"
" */\n"
"inline real IMAG(field z) {\n"
"  return z.y;\n"
"}\n"
"\n"
"/**\n"
" * @brief Performs a complex multiplication of two complex numbers x and y.\n"
" *\n"
" * @param x 1st factor of the complex product.\n"
" * @param y 2nd factor of the complex product.\n"
" * @return Returns the product @f$ x \times y@f$.\n"
" */\n"
"inline field cmul(field x, field y) {\n"
"  return (field) (x.x * y.x - x.y * y.y, x.x * y.y + x.y * y.x);\n"
"}\n"
"#else\n"
"\n"
"#endif\n"
};

/**
 * @}
 */

#endif /* CLSETTINGS_H_ */
